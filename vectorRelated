for vector<vector<xxx>> v2d:

int size_row = v2d.size();
int size_col = v2d[0].size();

一个待查的问题 关于 empty 和 size（） 
[]
[[]]

对于这种2d empty 只包上面不包下面

尽量使用empty而不是size()==0 来判断容器是否为空//empty（）是常数时间，size（）不是

1.insert() （3种）
A. 插入一个元素
iterator insert (iterator position, const value_type& val);
例子：
  it = myvector.begin();  //另外，it 是begin时是在最前面（第0个元素前）插入， 
  it = myvector.insert ( it , 200 );
  v.insert(v.begin()+2,1);   // 在第二个元素前插入新元素 
  v.insert(v.end(),3);       //end（）是在在末尾追加新元素
  vector<int>::iterator iter = find( v1.begin(), v1.end(), 3); //利用find function 找到iter指定位置
  if( iter !=  v1.end() ){    //也是用iter是否是end（）来看表中有木有这个元素
    v1.insert( iter, 6 );
  }


B. 插入几个相同元素， 第二个参数是几个 
void insert (iterator position, size_type n, const value_type& val);
例子：
 myvector.insert (it,2,300); //此时之前定义的it已经不再valid了，需要重新assign 


C 插入一个range；传的参数：加入位置，要加的range，需要用iterator表示
void insert (iterator position, InputIterator first, InputIterator last);

例子：把一个vector里的元素append入另外一个vector
std::vector<int> src;
std::vector<int> dest;
dest.insert(dest.end(), src.begin(), src.end());




参考：http://www.cplusplus.com/reference/vector/vector/insert/


2.初始化方式
eg:有另一数组 int  v1[10] = {0,1,0,0,3,0,0,4,4,4};

A.循环增加
vector<int> v2 (10) //初始化size为10
//或者 v2.reserve(10)
for( int i=0; i<10; i++ )
{
     v2.push_back(v1[i]);  //增加一个元素
}

B.使用原数组的指针作为迭代器
vector<int> v3(&v1[0],&v1[9]);

C.insert来实现
vector<int> v4;
v4.reserve(10);
v4.insert(v4.begin(), &v1[0], &v[9]);

D.copy
vector<int> v5(10);

copy(v5.begin(), &v1[0], &v1[9]);

原始数组的元素指针可以作为迭代器来使用。
原则：尽量使用reserve来减少不必要的内存分配次数。//如果已知大小的话


3.遍历的几种方式
方式1：for loop 循环
for( int i=0; i<v1.size(); i++ ){
       print(v1[i]);
}
缺点 不够简洁
方式2：for+迭代器range
typedef  vector<int>:: iterator   VIntIterator;
VIntIterator  end = v1.end();
for( VIntIterator  i=v1.begin(); i != end;  ++i ){
     print( *i );
}

先计算end 不必要每次去重复计算end,vector的end()不是常数时间的，所以先缓存下来能提高效率。
写算法的时候尽量使用!=比较迭代器，因为<对于很多非随机迭代器没有这个操作符。 
这种方式也写起来比较繁琐。

方式3：利用for_each (algorithm)
//std::for_each is an STL algorithm 
//it takes a collection of elements (in the form of a begin and end iterator) 
//and a function (or function object), and applies the function on each element of the collection. 

for_each( v1.begin(),  v1.end(),  print );

std::vector<int> numbers = {1, 2, 3, 4, 5};
std::for_each(begin(numbers), end(numbers), f);  //applies the function f on each element of numbers.

使用算法的时候和函数对象function object 例子
class OutPut{
public:
       void operator ()( double  i ){
          std::cout <<  i;
       }
}
for_each( v1.begin(), v1.end(), OutPut );

对于for_each() 的一点补充：
//bad usage
std::for_each(begin(numbers), end(numbers), [](int number)
{
    // do something with number
});
for_each is a tool for raising the level of abstraction of a range-based for loop. 
And showing the inside of the lambda within the call to for_each kills this purpose.

ref：https://www.fluentcpp.com/2018/03/30/is-stdfor_each-obsolete/ 
ref：https://www.cnblogs.com/caoshenghe/archive/2010/01/31/1660399.html


