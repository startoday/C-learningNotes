
1. To find max and min in a set:
Using set.begin() and set.end() methods
Approach: Elements in a set are stored in sorted order. 
So the minimum element of the set will reside in the first element and the maximum element in the last element. 
Therefore, this first and last element can be fetched with the help of set.begin() and set.end() methods respectively.
//例子有问题， 应该是 *（--my_set.end())因为end并不是存在的最后一个元素
eg:
int findMax(set<int> my_set) 
{ 
  
    // Get the maximum element 
    int max_element; 
    if (!my_set.empty()) 
        max_element = *my_set.end(); 
  
    // return the maximum element 
    return max_element; 
} 
  
// Function to find the minimum element 
int findMin(set<int> my_set) 
{ 
  
    // Get the minimum element 
    int min_element; 
    if (!my_set.empty()) 
        min_element = *my_set.begin(); 
  
    // return the minimum element 
    return min_element; 
} 

ref: https://www.geeksforgeeks.org/find-maximum-and-minimum-element-in-a-set-in-c-stl/ 


2. find（） 查找某元素所在位置，return 一个 iterator， 如果没有，会return set.end（）
//似乎set 没有contain这个function， 但是find 可以作为代替

例子：
    unordered_set<string> sampleSet = { "geeks1", "for", "geeks2" }; 
  
    // use of find() function 
    if (sampleSet.find("geeks1") != sampleSet.end()) { 
        cout << "element found." << endl; 
    } 
    else { 
        cout << "element not found" << endl; 
    } 
    
    
 ref：https://www.geeksforgeeks.org/unordered_set-find-function-in-c-stl/ 
 
 
 
 3.count（）
 值得注意的是set不允许重复元素，所以count是1 或者 0， 可以用来查找是否存在该元素，和countain一样
 运用也是 set.count(要找的东西）；
 
begin() 返回指向第一个元素的迭代器
clear() 清除所有元素
count() 返回某个值元素的个数
empty() 如果集合为空，返回true(真）
end() 返回指向最后一个元素之后的迭代器，不是最后一个元素
equal_range() 返回集合中与给定值相等的上下限的两个迭代器
erase() 删除集合中的元素
find() 返回一个指向被查找到元素的迭代器
get_allocator() 返回集合的分配器
insert() 在集合中插入元素
lower_bound() 返回指向大于（或等于）某值的第一个元素的迭代器
key_comp() 返回一个用于元素间值比较的函数
max_size() 返回集合能容纳的元素的最大限值
rbegin() 返回指向集合中最后一个元素的反向迭代器
rend() 返回指向集合中第一个元素的反向迭代器
size() 集合中元素的数目
swap() 交换两个集合变量
upper_bound() 返回大于某个值元素的迭代器
value_comp() 返回一个用于比较元素间的值的函数
